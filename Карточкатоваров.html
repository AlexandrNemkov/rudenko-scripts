<!--NOLIM--><!--NLM150--><!--settings{"comment":"","zeroId":"#rec1450750621","mainShapeClass":"tn-elem__14507506211760890267356","titleSettings":{"class":"tn-elem__1450750621176096459787649250","additional":"fonShapeForTitle150","marginBottom":"64","marginBottomMobile":"0"},"descriptionSettings":{"class":"tn-elem__1450750621176088924800187760","classesForNotClones":"description-title150","additional":"fonShapeForDescription150","marginBottom":"34","marginBottomMobile":"0"},"priceSettings":{"class":"tn-elem__1450750621176088907676191580","textBeforePrice":"","priceCurrency":"  ₽","marginBottom":"32","marginBottomMobile":"0"},"characteristicsSettings":{"classForName":"characteristics-name150","classForValue":"characteristics-value150","classesForClones":"deco-element1, deco-element2","classesForNotClones":"characteristics-title150","additional":"fonShapeForCharacteristics150","padding":"15","marginBottom":"50","marginBottomMobile":"0"},"brandSettings":{"class":"nlm_brand150","marginBottom":"50","marginBottomMobile":"0"},"optionsSettings":{"classForSelect":"class-for-select150","classesForClones":"select-deco-element1, select-deco-element2","classesForNotClones":"options-title150","additional":"fonShapeForSelect","marginBottom":"50","marginBottomMobile":"0"},"gallerySettings":{"class":"tn-elem__14507506211760950710118","marginBottom":"50","marginBottomMobile":"50"},"addToCartBtnSettings":{"class":"tn-elem__14507506211760888749616","marginBottom":"0","marginBottomMobile":"0"},"notAvailableSettings":{"notAvailableCheckbox":"false","notAvailableText":"","notAvailableBtnColor":"#ffffff","notAvailableLink":"#popup:myform","hiddenField":"myInput","myProductLink":"#myProduct"},"addToWishBtnSettings":{"addFavoriteClass":"tn-elem__14507506211760888887430","removeFavoriteClass":"removeFavoriteClassNlm150","classesForNotClones":"favorite-shape150","marginBottom":"50","marginBottomMobile":"50"},"loaderSettings":{"isOffLoader":"1","color":"#ffffff","colorBackground":"#ffffff"}}settingsend--><!--ts1760964698598ts--> 
<script src="https://static.tildacdn.com/js/jquery-1.10.2.min.js" charset="utf-8" onerror="this.loaderr='y';"></script>
<script> 
window.isAllElemsRendered1450750621 = false; 
let ab2 = setInterval(function() { 
    if (window.t396_allelems__renderView != undefined) { 
        clearInterval(ab2); 
        window.t396_allelems__renderView = function(artBoard) { 
            if (!artBoard) return false; 
            var ArtBoardelements = artBoard.querySelectorAll('.tn-elem'); 
            Array.prototype.forEach.call(ArtBoardelements, function (element) { 
                t396_elem__renderView(element); 
            }); 
            if (artBoard.closest(".r").id == 'rec1450750621') { 
                window.isAllElemsRendered1450750621 = true; 
            } 
        }; 
        const zeroBlock = document.querySelector('#rec1450750621 .t396__artboard'); 
        window.t396_allelems__renderView(zeroBlock); 
    } 
}, 10); 
function n_ready(t) { 
    "loading" != document.readyState ? t() : document.addEventListener ? document.addEventListener("DOMContentLoaded", t) : document.attachEvent("onreadystatechange", function() { 
        "loading" != document.readyState && t() 
    }) 
}; 
n_ready(function(){ 
    if(1 !== 1) { 
        loaderShow(); 
    } 
    let maxBottom1 = 0; 
    let maxBottom2 = 0; 
    let maxBottomInShape = 0; 
    let newMaxBottomInShape = 0; 
    let zeroId = "#rec1450750621"; 
    let titleClass = "tn-elem__1450750621176096459787649250"; 
    let titleFonShapeClass = "fonShapeForTitle150"; 
    let titleMarginBottom = 64; 
    let titleMarginBottomMobile = 0; 
    let descriptionClass = "tn-elem__1450750621176088924800187760"; 
    let descriptionFonShapeClass = "fonShapeForDescription150"; 
    let descriptionNotClonesClassesList = "description-title150"; 
    let descriptionMarginBottom = 34; 
    let descriptionMarginBottomMobile = 0; 
    let priceClass = "tn-elem__1450750621176088907676191580"; 
    let priceFonShapeClass = "nlm150-price-fon-shape-class"; 
    let priceMarginBottom = 32; 
    let priceMarginBottomMobile = 0; 
    let characteristicsNameClass = "characteristics-name150"; 
    let characteristicsValueClass = "characteristics-value150"; 
    let characteristicsFonShapeClass = "fonShapeForCharacteristics150"; 
    let characteristicsMarginBottom = 50; 
    let characteristicsMarginBottomMobile = 0; 
    let characteristicsClonesClassesList = "deco-element1, deco-element2"; 
    let characteristicsNotClonesClassesList = "characteristics-title150"; 
    let brandClass = "nlm_brand150"; 
    let brandFonShapeClass = "nlm150-brand-fon-shape-class"; 
    let brandMarginBottom = 50; 
    let brandMarginBottomMobile = 0; 
    let optionsSelectClass = "class-for-select150"; 
    let optionsFonShapeClass = "fonShapeForSelect"; 
    let optionsMarginBottom = 50; 
    let optionsMarginBottomMobile = 0; 
    let optionsClonesClassesList = "select-deco-element1, select-deco-element2"; 
    let optionsNotClonesClassesList = "options-title150"; 
    let galleryClass = "tn-elem__14507506211760950710118"; 
    let galleryFonShapeClass = "nlm150-gallery-fon-shape-class"; 
    let galleryMarginBottom = 50; 
    let galleryMarginBottomMobile = 50; 
    let addToCartBtnClass = "tn-elem__14507506211760888749616"; 
    let buyButtonFonShapeClass = "nlm150-buy-button-fon-shape-class"; 
    let buyButtonMarginBottom = 0; 
    let buyButtonMarginBottomMobile = 0; 
    let addToWishBtnClass = "tn-elem__14507506211760888887430"; 
    let removeFromWishBtnClass = "removeFavoriteClassNlm150"; 
    let forWishNotClonesClassesList = "favorite-shape150"; 
    let wishButtonMarginBottom = 50; 
    let wishButtonMarginBottomMobile = 50; 
    let wishButtonFonShapeClass = "nlm150-wish-button-fon-shape-class"; 
    let mainShape = document.querySelector(zeroId + ' .' + "tn-elem__14507506211760890267356"); 
    let settings1v6h6i5s2n9b6k0s6n7 = { 
        characteristics: { 
            productSelector: '.t-store__prod-snippet__container .t-typography__characteristics', 
            selectors: [ 
                { selector: zeroId + ' .' + characteristicsNameClass, value: '', editable: true }, 
                { selector: zeroId + ' .' + characteristicsValueClass, value: '', editable: true }, 
            ], 
            elemsHeight: [ { selector: zeroId + ' .' + characteristicsFonShapeClass } ], 
            padding: 15, 
            totalHeight: 0, 
            clonedElements: [], 
            marginBottom: characteristicsMarginBottom, 
            marginBottomMobile: characteristicsMarginBottomMobile, 
        }, 
        options: { 
            productSelector: '.t-store__product-snippet .t-product__option', 
            selectors: [ 
                { selector: zeroId + ' .' + optionsSelectClass, value: '', type: 'option', editable: true }, 
            ], 
            elemsHeight: [ { selector: zeroId + ' .' + optionsFonShapeClass } ], 
            padding: 15, 
            totalHeight: 0, 
            clonedElements: [], 
            marginBottom: optionsMarginBottom, 
            marginBottomMobile: optionsMarginBottomMobile, 
        }, 
        title: { 
            productSelector: '.t-store__prod-snippet__container .js-store-product .js-product-name', 
            selectors: [ 
                { selector: zeroId + ' .' + titleClass, value: '', type: 'title', editable: true }, 
            ], 
            elemsHeight: [ { selector: zeroId + ' .' + titleFonShapeClass } ], 
            padding: 15, 
            totalHeight: 0, 
            clonedElements: [], 
            marginBottom: titleMarginBottom, 
            marginBottomMobile: titleMarginBottomMobile, 
            checkDistanceMobile: titleMarginBottom, 
        }, 
        brand: { 
            productSelector: '.t-store__prod-snippet__container .js-product-brand', 
            selectors: [ 
                { selector: zeroId + ' .' + brandClass, value: '', type: 'brand', editable: true }, 
            ], 
            elemsHeight: [ { selector: zeroId + ' .' + brandFonShapeClass } ], 
            padding: 15, 
            totalHeight: 0, 
            clonedElements: [], 
            marginBottom: brandMarginBottom, 
            marginBottomMobile: brandMarginBottomMobile, 
        }, 
        descriptions: { 
            productSelector: '.t-store__prod-snippet__container .js-store-prod-all-text', 
            selectors: [ 
                { selector: zeroId + ' .' + descriptionClass, value: '', type: 'descriptions', editable: true }, 
            ], 
            elemsHeight: [ { selector: zeroId + ' .' + descriptionFonShapeClass } ], 
            padding: 15, 
            totalHeight: 0, 
            clonedElements: [], 
            marginBottom: descriptionMarginBottom, 
            marginBottomMobile: descriptionMarginBottomMobile, 
        }, 
        price: { 
            productSelector: '.t-store__prod-snippet__container .js-store-product .js-product-price', 
            selectors: [ 
                { selector: zeroId + ' .' + priceClass, value: '', type: 'price', editable: true }, 
            ], 
            elemsHeight: [ { selector: zeroId + ' .' + priceFonShapeClass } ], 
            padding: 15, 
            totalHeight: 0, 
            clonedElements: [], 
            marginBottom: priceMarginBottom, 
            marginBottomMobile: priceMarginBottomMobile, 
        }, 
        gallery: { 
            selectors: [{ selector: zeroId + ' .' + galleryClass, value: '', type: 'gallery', editable: true }, ], 
            elemsHeight: [{ selector: zeroId + ' .' + galleryFonShapeClass }], 
            padding: 15, 
            totalHeight: 0, 
            clonedElements: [], 
            marginBottom: galleryMarginBottom, 
            marginBottomMobile: galleryMarginBottomMobile, 
        }, 
        buyButton: { 
            selectors: [{ selector: zeroId + ' .' + addToCartBtnClass, value: '', type: 'buy-button', editable: true },], 
            elemsHeight: [{ selector: zeroId + ' .' + buyButtonFonShapeClass }], 
            padding: 15, 
            totalHeight: 0, 
            clonedElements: [], 
            marginBottom: buyButtonMarginBottom, 
            marginBottomMobile: buyButtonMarginBottomMobile, 
        }, 
        wishButton: { 
            selectors: [ 
                {selector: zeroId + ' .' + addToWishBtnClass, value: '', type: 'wish-button', editable: true}, 
                {selector: zeroId + ' .' + removeFromWishBtnClass, value: '', type: 'wish-button', editable: true}, 
            ], 
            elemsHeight: [{ selector: zeroId + ' .' + wishButtonFonShapeClass }], 
            padding: 15, 
            totalHeight: 0, 
            clonedElements: [], 
            marginBottom: wishButtonMarginBottom, 
            marginBottomMobile: wishButtonMarginBottomMobile, 
        } 
    }; 
    /* Добавляем дополнительные элементы к общему объекту */ 
    function addSelectorToMainObj(selectorsList, notCloneable, type) { 
        if (selectorsList) { 
            let arr = selectorsList.replace(/\s+/g, '').split(','); 
            arr.forEach(function(cls) { 
                let obj = { selector: zeroId + ' .' + cls, value: null, type: 'decoration', notCloneable: notCloneable }; 
                settings1v6h6i5s2n9b6k0s6n7[type].selectors.push(obj); 
            }); 
        } 
    } 
    addSelectorToMainObj(characteristicsClonesClassesList, false, "characteristics"); 
    addSelectorToMainObj(characteristicsNotClonesClassesList, true, "characteristics"); 
    addSelectorToMainObj(optionsClonesClassesList, false, "options"); 
    addSelectorToMainObj(optionsNotClonesClassesList, true, "options"); 
    addSelectorToMainObj(descriptionNotClonesClassesList, true, "descriptions"); 
    addSelectorToMainObj(forWishNotClonesClassesList, true, "wishButton"); 
    function loaderShow() { 
        const parentNode = document.querySelector('.t-records'); 
        parentNode.insertAdjacentHTML("beforeend", ` 
            <div class="loader__overlay"> 
                <div class="loader__container"> 
                    <div class="loader"></div> 
                </div> 
            </div> 
        `); 
    } 
    function loaderHide() { 
        document.querySelectorAll('.loader__overlay').forEach((el) => { 
            el.remove(); 
        }); 
    } 
    function checkZoom3z8g2l3q2q6k2h2r0i8(el) { 
        let myZoom = 1; 
        if (window.isFirefox || window.isOpera) { 
            let scaleWrapper = el.querySelector(".tn-atom__scale-wrapper"); 
            if (scaleWrapper) { 
                myZoom = scaleWrapper.style.transform.replace(/[^0-9,.]/g,""); 
                let int2 = setInterval(function() { 
                    scaleWrapper = el.querySelector(".tn-atom__scale-wrapper"); 
                    let z1 = scaleWrapper.style.transform.replace(/[^0-9,.]/g,""); 
                    if (z1 != myZoom) { 
                        myZoom = scaleWrapper.style.transform.replace(/[^0-9,.]/g,""); 
                    } 
                }, 100); 
            } 
        } else { 
            if (el.style.zoom != "") { 
                myZoom = el.style.zoom; 
                let int2 = setInterval(function() { 
                    let z1 = el.style.zoom; 
                    if (z1 != myZoom) { 
                        myZoom = el.style.zoom; 
                    } 
                }, 10); 
            } 
        } 
        return myZoom; 
    } 
    function calculateGroupHeight3j0x2l4s2p4p2n3u4z5(selectors) { 
        let zm = 1; 
        selectors.forEach(function(item) { 
            let element = document.querySelector(item); 
            if (element) { 
                let elemZoom = checkZoom3z8g2l3q2q6k2h2r0i8(element); 
                if (elemZoom != 1) { 
                    zm = elemZoom; 
                } 
            } 
        }); 
        let elements = selectors.map(sel => { 
            let elem = document.querySelector(sel); 
            if (elem) { 
                let styles = window.getComputedStyle(elem); 
                let stylesTop = parseInt(styles.top); 
                if (elem.hasAttribute("data-scale-off") && elem.getAttribute("data-scale-off") == "yes") { 
                    stylesTop = parseInt(styles.top) / zm; 
                } 
                return { elem: elem, top: Math.round(stylesTop), height: parseInt(styles.height) }; 
            } 
            return false; 
        }); 
        let filteredElements = elements.filter((element) => element !== false); 
        filteredElements.sort((a, b) => a.top - b.top); 
        let totalHeight = 0; 
        let maxBottom = 0; 
        let top = 0; 
        for(const {top: currentTop, height: currentHeight} of filteredElements) { 
            let currentBottom = currentTop + currentHeight; 
            if (currentTop < top || top == 0){ 
                top = currentTop; 
            } 
            if(currentBottom > maxBottom) { 
                if(maxBottom > top) { 
                    totalHeight += currentBottom - maxBottom; 
                } else { 
                    totalHeight += currentHeight; 
                } 
                maxBottom = currentBottom; 
            } 
        } 
        return totalHeight; 
    } 
    function increaseHeight5a5r3l8o8y6c3z3l3c8({ selector, updateValue }={}) { 
        const element = document.querySelector(selector); 
        if(updateValue && element){ 
            let h = window.getComputedStyle(element); 
            let heightelem = parseInt(h.height) + updateValue; 
            element.style.height = parseInt(h.height) + updateValue + 'px'; 
        } 
    } 
    function updateElement3s4y0s1v1e8q2e0w4x3({ selector, updateValue, type, isClone = false, elem } = {}) { 
        let element = document.querySelector(selector); 
        if (!element) { 
            return; 
        } 
        if (elem) { 
            element = elem; 
        } 
        if (type === 'options' && updateValue) { 
            const titleElement = element.querySelector('.t-input-group_sb .t-input-title'); 
            if (titleElement && updateValue.title) { 
                titleElement.innerHTML = updateValue.title; 
            } 
            let select = element.querySelector('select'); 
            if (select) { 
                select.innerHTML = ''; 
                select.classList.remove('t-select'); 
                select.classList.add('t-nolim-select'); 
                updateValue.optionsList.forEach(optionValue => { 
                    const optionElement = document.createElement('option'); 
                    optionElement.value = optionValue; 
                    optionElement.text = optionValue; 
                    if (updateValue.optionsDisabledList.includes(optionValue)) { 
                        optionElement.setAttribute("disabled", "disabled"); 
                    } 
                    select.appendChild(optionElement); 
                }); 
                if (!isClone) { 
                    select.addEventListener("change", function(e) { 
                        emulateChange4z5a8f8x0j9k3d5h1m1(e.target); 
                    }); 
                } 
                if (updateValue.selectValue) { 
                    select.value = updateValue.selectValue; 
                } 
            } 
        } else if (updateValue) { 
            let uElem = element.querySelector('u'); 
            if(uElem) { 
                uElem.innerHTML = updateValue; 
            } else { 
                const tnAtomElement = element.querySelector('.tn-atom'); 
                const tnAtomStyle = window.getComputedStyle(tnAtomElement); 
                const tnAtomFontFamily = tnAtomStyle.fontFamily; 
                if(type === 'descriptions') { 
                    tnAtomElement.style.fontSize = tnAtomStyle.fontSize; 
                    tnAtomElement.classList.remove('tn-atom'); 
                } 
                if (tnAtomElement) { 
                    tnAtomElement.innerHTML = updateValue; 
                } 
                if(tnAtomFontFamily) { 
                    tnAtomElement.style.fontFamily = tnAtomFontFamily; 
                } 
            } 
        } 
    } 
    function cloneAndUpdateElement5a6r5u4j4s1k8s9h9a6({ selector, updateValue, type, editable = false, isClone = true, notCloneable = false } = {}){ 
        if (notCloneable) { 
            return false; 
        } 
        const elementsList = document.querySelectorAll(selector); 
        Array.from(elementsList).forEach(element => { 
            if (element) { 
                const clonedElement = element.cloneNode(true); 
                if(updateValue && editable){ 
                    if(type === 'characteristics') { 
                        updateElement3s4y0s1v1e8q2e0w4x3({ selector, updateValue, type, isClone, elem: clonedElement}); 
                    } else { 
                        updateElement3s4y0s1v1e8q2e0w4x3({ selector, updateValue, type, isClone, elem: clonedElement }); 
                    } 
                } 
                let newTop = calculateNewTopValue9k5n6f8k1m7r3t4c4o5({ settings1v6h6i5s2n9b6k0s6n7: settings1v6h6i5s2n9b6k0s6n7, type: type, element: element }); 
                changeTop2f6o3h9i2f2p2o3t7e4({ value: newTop, selector: selector, type: type, element: clonedElement }); 
                settings1v6h6i5s2n9b6k0s6n7[type].clonedElements.push(clonedElement); 
                window.settings1v6h6i5s2n9b6k0s6n7 = settings1v6h6i5s2n9b6k0s6n7; 
                element.parentNode.appendChild(clonedElement); 
                if (clonedElement.querySelector("select")) { 
                    let newId = getRandomSelectId5k4f0o8v4f5o2g0w4j0(); 
                    clonedElement.querySelector("select").id = `sb-${newId}`; 
                    if (clonedElement.querySelector(".t-input-group label")) { 
                        clonedElement.querySelector(".t-input-group label").setAttribute("for", `sb-${newId}`); 
                    } 
                } 
                if (type == "options" && clonedElement.querySelector("select")) { 
                    function forClonedElementEventListener(e) { 
                        emulateChange4z5a8f8x0j9k3d5h1m1(e.target); 
                    } 
                    clonedElement.querySelector("select").removeEventListener("change", forClonedElementEventListener); 
                    clonedElement.querySelector("select").addEventListener("change", forClonedElementEventListener); 
                } 
            } 
        }); 
    } 
    function getRandomSelectId5k4f0o8v4f5o2g0w4j0() { 
        const maxDigits = 13; 
        let randomNumber = Math.random().toString().slice(2); 
        while (randomNumber.length < maxDigits) { 
            randomNumber += Math.random().toString().slice(2); 
        } 
        randomNumber = randomNumber.substring(0, maxDigits); 
        return parseInt(randomNumber, 10); 
    } 
    function emulateChange4z5a8f8x0j9k3d5h1m1(target) { 
        document.querySelectorAll(".t-store__prod-snippet__container .t-product__option-title").forEach(function(item) { 
            if (item.innerHTML == target.closest(".t-input-group").querySelector("label").innerHTML) { 
                item.closest(".t-product__option").querySelector("select").value = target.value; 
                item.closest(".t-product__option").querySelector("select").dispatchEvent(new Event('change')); 
                setTimeout(function() { 
                    getProp1c4k5r9r8t7b2s6j9w8({ type: 'options', update: true }); 
                    getProp1c4k5r9r8t7b2s6j9w8({ type: 'price' }); 
                },1000); 
            } 
        }); 
    } 
    function calculateNewTopValue9k5n6f8k1m7r3t4c4o5({ settings1v6h6i5s2n9b6k0s6n7, type, element }={}){ 
        let zm = 1; 
        if (element.hasAttribute("data-scale-off") && element.getAttribute("data-scale-off") == "yes") { 
            element.closest(".t396__artboard").querySelectorAll(".t396__elem").forEach(function(item) { 
                let elemZoom = checkZoom3z8g2l3q2q6k2h2r0i8(item); 
                if (elemZoom != 1) { 
                    zm = elemZoom; 
                } 
            }); 
        } 
        return `${Math.round(parseInt(getComputedStyle(element).top) + settings1v6h6i5s2n9b6k0s6n7[type].padding * zm + settings1v6h6i5s2n9b6k0s6n7[type].totalHeight * zm)}px`; 
    } 
    function changeTop2f6o3h9i2f2p2o3t7e4({ value, selector, type, element }={}){ 
        element.style.top = value; 
        element.setAttribute('data-field-top-value', value.replace("px","")); 
        element.setAttribute('data-field-top-res-1200-value', value.replace("px","")); 
        if(selector){ 
            let selectorParts = selector.split(' '); 
            element.classList.remove(selectorParts[1].replace('.', '')); 
            element.classList.add(type+'_cloned'); 
        } 
    } 
    function activateButton4e6c6l4f7y0l5n9s1q7() { 
        let buttonsList = document.querySelectorAll(zeroId + ' .' + addToCartBtnClass); 
        // Добавляем мобильную кнопку корзины
        const mobileCartButton = document.querySelector('.tn-elem__1527711121176244292346964490');
        if (mobileCartButton) {
            buttonsList = Array.from(buttonsList);
            buttonsList.push(mobileCartButton);
        }
        let leftover = document.querySelector('.t-store__prod-snippet__container .js-store-product')?.getAttribute('data-product-inv'); 
        const defaultOrderButton = document.querySelector('.t-store__prod-snippet__container a[href="#order"]'); 
        
            // Функция для получения цены
        function getPrice() {
            const priceElem = document.querySelector('.js-store-prod-price-val.t-store__prod-popup__price-value');
            return priceElem ? priceElem.innerText : '';
        }
        
        // Глобальная функция для обновления текста кнопки в мобильной версии
        window.updateButtonTextForMobile = function() {
            if (window.innerWidth <= 640) {
                const buttons = document.querySelectorAll(zeroId + ' .' + addToCartBtnClass + ' .tn-atom');
                buttons.forEach(function(btn) {
                    const price = getPrice();
                    if (price) {
                        btn.innerText = 'Купить за ' + price;
                    }
                });
                // Обновляем текст мобильной кнопки корзины
                const mobileCartBtnAtom = mobileCartButton?.querySelector('.tn-atom');
                if (mobileCartBtnAtom) {
                    const price = getPrice();
                    if (price) {
                        mobileCartBtnAtom.innerText = 'Купить за ' + price;
                    }
                }
            }
        };
        
        // Функция для изменения текста кнопки в мобильной версии
        function updateButtonText() {
            if (window.innerWidth <= 640) {
                buttonsList.forEach(function(btn) {
                    const btnAtom = btn.querySelector('.tn-atom');
                    if (btnAtom) {
                        const price = getPrice();
                        if (price) {
                            btnAtom.innerText = 'Купить за ' + price;
                        }
                    }
                });
            }
        }
        
        // Вызываем обновление текста при загрузке
        updateButtonText();
        
        // Обновляем текст при изменении размера окна
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(updateButtonText, 100);
        });
        
        if (buttonsList.length > 0) { 
            buttonsList.forEach(function(item) { 
                const itemTnAtom = item.querySelector('.tn-atom'); 
                if (+leftover < 1 && (leftover !== '') && false == false) { 
                    itemTnAtom.innerText = 'нет в наличии'; 
                    itemTnAtom.style.setProperty('background-color', "#ffffff"); 
                    itemTnAtom.style.setProperty('background-image', 'none'); 
                    itemTnAtom.style.setProperty('opacity', '0.6'); 
                    item.style.setProperty('pointer-events', 'none'); 
                } else if (+leftover < 1 && (leftover !== '') && false == true) { 
                    itemTnAtom.innerText = 'нет в наличии'; 
                    defaultOrderButton.href = '#popup:myform'; 
                    itemTnAtom.style.setProperty('background-color', "#ffffff"); 
                    itemTnAtom.style.setProperty('background-image', 'none'); 
                    item.addEventListener('click', function() { 
                        defaultOrderButton.click(); 
                        let productNameLink = document.querySelector('[data-tooltip-hook="#popup:myform"] [href="#myProduct"]'); 
                        if(productNameLink) { 
                            productNameLink.innerText = document.querySelector('.tn-elem__1450750621176096459787649250 .tn-atom').innerText; 
                        } 
                        let hiddenInput = document.querySelector('[name="myInput"]'); 
                        let nlstr = ''; 
                        let productName = document.querySelector('.tn-elem__1450750621176096459787649250 .tn-atom'); 
                        let productSku = document.querySelector('.js-store-product').getAttribute('data-product-lid'); 
                        if(productName) { 
                            nlstr += productName.innerHTML + ';'; 
                        } 
                        if(productSku) { 
                            nlstr += productSku + ';'; 
                        } 
                        if (hiddenInput) { 
                            hiddenInput.value = nlstr; 
                        } 
                    }); 
                } else { 
                    item.addEventListener('click', function() { 
                        if(defaultOrderButton){ 
                            defaultOrderButton.click(); 
                        } 
                    }); 
                } 
            }); 
        } 
    } 
    function activateWishButton6z4s7y2e0x9n1x2r0h8() { 
        let addButtonList = document.querySelectorAll(zeroId + ' .' + addToWishBtnClass); 
        let removeButtonList = document.querySelectorAll(zeroId + ' .' + removeFromWishBtnClass); 
        // Добавляем мобильную кнопку избранного
        const mobileFavoriteButton = document.querySelector('.tn-elem__1527711121176244292347471240');
        if (mobileFavoriteButton) {
            addButtonList = Array.from(addButtonList);
            addButtonList.push(mobileFavoriteButton);
        }
        let intForFavoriteButton = setInterval(() => { 
            let favoriteButton = document.querySelector('.t-store__prod-snippet__container a[href="#addtofavorites"]'); 
            if (favoriteButton) { 
                clearInterval(intForFavoriteButton); 
                function checkIsFavoriteProduct () { 
                    if(favoriteButton) { 
                        const isFavorite = favoriteButton.classList.contains('t1002__addBtn_active'); 
                        if(isFavorite) { 
                            addButtonList.forEach((addButton) => { 
                                addButton.classList.add('nolimAutoScaleFix'); 
                            }); 
                            removeButtonList.forEach((addButton) => { 
                                addButton.classList.remove('nolimAutoScaleFix'); 
                            }); 
                        } else { 
                            addButtonList.forEach((addButton) => { 
                                addButton.classList.remove('nolimAutoScaleFix'); 
                            }); 
                            removeButtonList.forEach((addButton) => { 
                                addButton.classList.add('nolimAutoScaleFix'); 
                            }); 
                        } 
                    } 
                } 
                function clickAddButton() { 
                    favoriteButton.click(); 
                    addButtonList.forEach((addButton) => { 
                        addButton.classList.add('nolimAutoScaleFix'); 
                    }); 
                    removeButtonList.forEach((addButton) => { 
                        addButton.classList.remove('nolimAutoScaleFix'); 
                    }); 
                } 
                function clickRemoveButton() { 
                    favoriteButton.click(); 
                    addButtonList.forEach((addButton) => { 
                        addButton.classList.remove('nolimAutoScaleFix'); 
                    }); 
                    removeButtonList.forEach((addButton) => { 
                        addButton.classList.add('nolimAutoScaleFix'); 
                    }); 
                } 
                if (addButtonList.length > 0) { 
                    addButtonList.forEach(function(item) { 
                        item.removeEventListener('click', clickAddButton); 
                        item.addEventListener('click', clickAddButton); 
                    }); 
                } 
                if (removeButtonList.length > 0) { 
                    removeButtonList.forEach(function(item) { 
                        item.removeEventListener('click', clickRemoveButton); 
                        item.addEventListener('click', clickRemoveButton); 
                    }); 
                } 
                checkIsFavoriteProduct(); 
                let intForWishPopup = setInterval(() => { 
                    let wishListBtnPopup = document.querySelector('.t1002__wishlisticon'); 
                    if(wishListBtnPopup) { 
                        clearInterval(intForWishPopup); 
                        function forWishListBtnPopupListener () { 
                            document.body.addEventListener('click', (e) => { 
                                if (e.target && e.target.closest("div").classList.contains('t1002__product-del')) { 
                                    checkIsFavoriteProduct(); 
                                } 
                            }); 
                        } 
                        wishListBtnPopup.removeEventListener('click', forWishListBtnPopupListener); 
                        wishListBtnPopup.addEventListener('click', forWishListBtnPopupListener); 
                    } 
                },100); 
                setTimeout(() => { 
                    clearInterval(intForWishPopup); 
                },1000); 
            } 
        },100); 
        setTimeout(() => { 
            clearInterval(intForFavoriteButton); 
        },1000); 
    } 
    function activateQuantity8v9w8b6n9d5e7m7v9o2() { 
        let productQuantityInput = document.querySelector('.t-store__prod__quantity-input'); 
        if (productQuantityInput) { 
            document.querySelectorAll('#nlm150quantityHide').forEach((el) => { 
                el.remove(); 
            }); 
            let quantityInput = document.querySelector(zeroId + ' .' + quantityClass + ' .t-inputquantity'); 
            quantityInput.value = productQuantityInput.value; 
            quantityInput.addEventListener('change', function() { 
                productQuantityInput.value = quantityInput.value; 
                productQuantityInput.dispatchEvent(new Event('change')); 
                setTimeout(function() { 
                    quantityInput.value = productQuantityInput.value; 
                },0); 
            }); 
            let minusButton = document.querySelector(zeroId + ' .' + quantityClass + ' .t-inputquantity__btn-minus'); 
            minusButton.addEventListener('click', function() { 
                document.querySelector('.t-store__prod__quantity__minus').click(); 
                setTimeout(function() { 
                    quantityInput.value = productQuantityInput.value; 
                },0); 
            }); 
            let plusButton = document.querySelector(zeroId + ' .' + quantityClass + ' .t-inputquantity__btn-plus'); 
            plusButton.addEventListener('click', function() { 
                document.querySelector('.t-store__prod__quantity__plus').click(); 
                setTimeout(function() { 
                    quantityInput.value = productQuantityInput.value; 
                },0); 
            }); 
        } 
    } 
    function setGallery2k7z8w6u5m7q9s1e9x6() { 
        let imgList = []; 
        let imgListLength; 
        let int1 = setInterval(function() { 
            let storeGallery = document.querySelector(".t-store__prod-snippet__container .js-store-product .js-store-prod-slider"); 
            if (storeGallery && storeGallery.querySelector(".t-slds__items-wrapper") && storeGallery.querySelector(".t-slds__items-wrapper").hasAttribute("data-slider-totalslides")) { 
                clearInterval(int1); 
                let totalSlides = Number(storeGallery.querySelector(".t-slds__items-wrapper").getAttribute("data-slider-totalslides")); 
                imgListLength = totalSlides; 
                let int2 = setInterval(function() { 
                    if (totalSlides && storeGallery.querySelector(`.t-slds__items-wrapper > div[data-slide-index="${totalSlides+1}"]`) && storeGallery.querySelector(`.t-slds__items-wrapper > div[data-slide-index="0"]`)) { 
                        clearInterval(int2); 
                        storeGallery.querySelectorAll(`.t-slds__items-wrapper > div:not([data-slide-index="0"]):not([data-slide-index="${totalSlides+1}"]):not(.t-slds__item_dummy)`).forEach(function(item) { 
                            let int3 = setInterval(function() { 
                                if (item.querySelector(".t-slds__bgimg") && item.querySelector(".t-slds__bgimg").hasAttribute("data-original")) { 
                                    clearInterval(int3); 
                                    imgList.push(item.querySelector(".t-slds__bgimg").getAttribute("data-original")); 
                                } 
                            },100); 
                            setTimeout(() => { 
                                clearInterval(int3); 
                            },7000); 
                        }); 
                    } 
                },100); 
                setTimeout(() => { 
                    clearInterval(int2); 
                },7000); 
            } 
        },100); 
        setTimeout(() => { 
            clearInterval(int1); 
        },7000); 
        let int4 = setInterval(function() { 
            let storeGallery = document.querySelector(".t-store__prod-snippet__container .js-store-product .js-store-prod-slider"); 
            if (document.querySelector(zeroId + ' [data-elem-type="gallery"]').hasAttribute("data-field-imgs-value")) { 
                clearInterval(int4); 
                let atr = JSON.parse(document.querySelector(zeroId + ' [data-elem-type="gallery"]').getAttribute("data-field-imgs-value")); 
                let int5 = setInterval(function() { 
                    if (imgList.length == imgListLength) { 
                        clearInterval(int5); 
                        let newAtr = []; 
                        for (let i = 0; i < imgList.length; i++) { 
                            let newObject = { ...atr[0] }; 
                            newObject.lid = String(newObject.lid) + (i+1); 
                            newObject["li_img"] = imgList[i]; 
                            newAtr.push(newObject); 
                        } 
                        newAtr = JSON.stringify(newAtr); 
                        document.querySelector(zeroId + ' [data-elem-type="gallery"]').setAttribute("data-field-imgs-value", newAtr); 
                        let recId = zeroId.replace("#rec", ""); 
                        let elemId = document.querySelector(zeroId + ' [data-elem-type="gallery"]').getAttribute("data-elem-id"); 
                        t_zeroGallery__init(recId, elemId); 
                        // Создаем галерею миниатюр после инициализации
                        setTimeout(() => {
                            createThumbnailGallery(imgList);
                        }, 500);
                    } 
                },100); 
                setTimeout(() => { 
                    clearInterval(int5); 
                },7000) 
            } 
        },100); 
        setTimeout(() => { 
            clearInterval(int4); 
        },7000) 
    } 
    
    // Функция для создания галереи миниатюр слева
    function createThumbnailGallery(imgList) {
        const galleryElement = document.querySelector(zeroId + ' [data-elem-type="gallery"]');
        if (!galleryElement || imgList.length === 0) return;
        
        // Проверяем, не создана ли уже галерея миниатюр
        if (galleryElement.parentNode.querySelector('.thumbnail-gallery-container')) return;
        
        // Создаем контейнер для миниатюр
        const thumbnailContainer = document.createElement('div');
        thumbnailContainer.className = 'thumbnail-gallery-container';
        
        // Создаем миниатюры для каждого изображения
        imgList.forEach((imgUrl, index) => {
            const thumbnail = document.createElement('div');
            thumbnail.className = 'thumbnail-item';
            if (index === 0) {
                thumbnail.classList.add('active');
            }
            thumbnail.setAttribute('data-thumb-index', index);
            
            const thumbnailImg = document.createElement('img');
            thumbnailImg.src = imgUrl;
            thumbnailImg.alt = 'Thumbnail ' + (index + 1);
            thumbnailImg.loading = 'lazy';
            
            thumbnail.appendChild(thumbnailImg);
            thumbnailContainer.appendChild(thumbnail);
            
            // Добавляем обработчик клика
            thumbnail.addEventListener('click', function() {
                // Убираем активный класс со всех миниатюр
                thumbnailContainer.querySelectorAll('.thumbnail-item').forEach(item => {
                    item.classList.remove('active');
                });
                // Добавляем активный класс к выбранной миниатюре
                thumbnail.classList.add('active');
                
                // Переключаем основное изображение в галерее
                const galleryBullets = galleryElement.querySelectorAll('.t-slds__bullet');
                if (galleryBullets[index]) {
                    galleryBullets[index].click();
                }
            });
        });
        
        // Обертываем галерею и миниатюры в контейнер, если его еще нет
        let galleryWrapper = galleryElement.parentNode.querySelector('.gallery-wrapper');
        if (!galleryWrapper) {
            galleryWrapper = document.createElement('div');
            galleryWrapper.className = 'gallery-wrapper';
            galleryElement.parentNode.insertBefore(galleryWrapper, galleryElement);
            galleryWrapper.appendChild(galleryElement);
        }
        
        // Вставляем контейнер миниатюр перед галереей внутри обертки
        galleryWrapper.insertBefore(thumbnailContainer, galleryElement);
        
        // Синхронизируем позицию миниатюр с галереей
        function alignThumbnails() {
            const galleryRect = galleryElement.getBoundingClientRect();
            const wrapperRect = galleryWrapper.getBoundingClientRect();
            const thumbnailRect = thumbnailContainer.getBoundingClientRect();
            
            // Вычисляем разницу в позиции
            const galleryTopInWrapper = galleryRect.top - wrapperRect.top;
            const thumbnailTopInWrapper = thumbnailRect.top - wrapperRect.top;
            const offset = galleryTopInWrapper - thumbnailTopInWrapper;
            
            if (Math.abs(offset) > 1) {
                thumbnailContainer.style.marginTop = offset + 'px';
            }
        }
        
        // Выравниваем после небольшой задержки, чтобы все стили применились
        setTimeout(alignThumbnails, 50);
        setTimeout(alignThumbnails, 200);
        setTimeout(alignThumbnails, 500);
        
        // Функция для синхронизации активной миниатюры
        function syncThumbnail(index) {
            thumbnailContainer.querySelectorAll('.thumbnail-item').forEach(item => {
                item.classList.remove('active');
            });
            const activeThumbnail = thumbnailContainer.querySelector(`[data-thumb-index="${index}"]`);
            if (activeThumbnail) {
                activeThumbnail.classList.add('active');
            }
        }
        
        // Синхронизируем активную миниатюру с текущим слайдом галереи
        const galleryBullets = galleryElement.querySelectorAll('.t-slds__bullet');
        galleryBullets.forEach((bullet, index) => {
            bullet.addEventListener('click', function() {
                syncThumbnail(index);
            });
        });
        
        // Также отслеживаем изменения через события слайдера
        const gallerySlider = galleryElement.querySelector('.t-slds');
        if (gallerySlider) {
            const observer = new MutationObserver(function(mutations) {
                const activeBullet = galleryElement.querySelector('.t-slds__bullet_active');
                if (activeBullet) {
                    const bulletIndex = Array.from(galleryBullets).indexOf(activeBullet);
                    if (bulletIndex !== -1) {
                        syncThumbnail(bulletIndex);
                    }
                }
            });
            
            observer.observe(galleryElement, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['class']
            });
        }
        
        // На мобильной версии отключаем клики на левую/правую область для переключения
        function disableGalleryAreaClicks() {
            if (window.innerWidth <= 640) {
                const galleryAreas = galleryElement.querySelectorAll('.t-slds__area');
                galleryAreas.forEach(area => {
                    // Отключаем pointer-events через CSS (уже сделано в стилях)
                    area.style.pointerEvents = 'none';
                    // Удаляем обработчики кликов, но оставляем touch события для свайпа
                    area.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }, true);
                });
            }
        }
        
        // Вызываем после инициализации галереи
        setTimeout(disableGalleryAreaClicks, 600);
        window.addEventListener('resize', disableGalleryAreaClicks);
    }
    
    setGallery2k7z8w6u5m7q9s1e9x6(); 
    function getProp1c4k5r9r8t7b2s6j9w8({ type, update = false }={}) { 
        if (type == "gallery") { 
            return false; 
        }
        let int = setInterval(function(){ 
            let chars = document.querySelectorAll(settings1v6h6i5s2n9b6k0s6n7[type].productSelector); 
            if(type === 'brand' && chars.length === 0) { 
                clearInterval(int); 
                const brandElem = document.querySelector(zeroId + ' .' + brandClass); 
                if(brandElem) { 
                    brandElem.style.display = 'none'; 
                } 
            } 
            if(type === 'options' && chars.length === 0) { 
                setTimeout(() => { 
                    if(chars.length === 0) { 
                        clearInterval(int); 
                        const optionsElemList = settings1v6h6i5s2n9b6k0s6n7[type].selectors.map((optionSelector) => { 
                            let optionsElem = document.querySelector(optionSelector.selector); 
                            if (optionsElem) { 
                                return optionsElem; 
                            } 
                        }).filter((value) => value !== undefined); 
                        if(optionsElemList.length) { 
                            optionsElemList.forEach((optionsElem) => { 
                                optionsElem.style.display = "none"; 
                            }); 
                        } 
                    } 
                },100); 
            } 
            if (chars.length) { 
                clearInterval(int); 
                if(type === 'price' && !chars[0].innerText) { 
                    settings1v6h6i5s2n9b6k0s6n7[type].selectors.forEach((item) => { 
                        let element = document.querySelector(item.selector); 
                        if(element) { 
                            element.style.display = "none"; 
                        } 
                    }); 
                } 
                if(type === 'price' && chars[0].innerText) { 
                    settings1v6h6i5s2n9b6k0s6n7[type].selectors.forEach((item) => { 
                        let element = document.querySelector(item.selector); 
                        if(element) { 
                            element.style.display = "block"; 
                        } 
                    }); 
                } 
                let increase; 
                let h_raznica; 
                if (!update) { 
                    let selectorsNames = []; 
                    settings1v6h6i5s2n9b6k0s6n7[type].selectors.forEach(function(sel) { 
                        if (!sel.notCloneable) { 
                            selectorsNames.push(sel.selector); 
                        } 
                    }); 
                    settings1v6h6i5s2n9b6k0s6n7[type].totalHeight = calculateGroupHeight3j0x2l4s2p4p2n3u4z5(selectorsNames); 
                    increase = settings1v6h6i5s2n9b6k0s6n7[type].totalHeight; 
                    h_raznica = settings1v6h6i5s2n9b6k0s6n7[type].totalHeight; 
                } 
                let myIndex = 0; 
                let counterForCharacteristics = 0; 
                chars.forEach((item, index) => { 
                    let selectObj = {}; 
                    if (type == "options") { 
                        selectObj.isUpdateOpts = update; 
                        selectObj.initElem = item; 
                        selectObj.selectValue = item.querySelector("select").value; 
                        selectObj.title = item.querySelector(".t-product__option-title").innerHTML; 
                        selectObj.optionsList = []; 
                        selectObj.optionsDisabledList = []; 
                        item.querySelectorAll("option").forEach(function(item) { 
                            selectObj.optionsList.push(item.value); 
                            if (item.hasAttribute("disabled")) { 
                                selectObj.optionsDisabledList.push(item.value); 
                            } 
                        }); 
                    } 
                    if (update) { 
                        let selectorsAfterClone = [".options_cloned"]; 
                        settings1v6h6i5s2n9b6k0s6n7.options.selectors.forEach(function(selector) { 
                            selectorsAfterClone.push(selector.selector); 
                        }); 
                        document.querySelectorAll(selectorsAfterClone.join(", ")).forEach(item => { 
                            if (item && item.querySelector(".t-form .t-input-group .t-input-title") && item.querySelector(".t-form .t-input-group .t-input-title").innerHTML == selectObj.title) { 
                                updateElement3s4y0s1v1e8q2e0w4x3({ selector: "no", updateValue: selectObj, type: "options", isClone: true, elem: item }); 
                            } 
                        }); 
                    } else { 
                        let textContent = type === 'descriptions' ? item.innerHTML : item.textContent; 
                        if (textContent) { 
                            if(type === "price" && ' ₽' && !item.textContent.includes(' ₽')) { 
                                item.textContent += ' ₽'; 
                                textContent += ' ₽'; 
                            } 
                            if(type === "price" && '' && !item.textContent.includes('')) { 
                                item.textContent = '' + item.textContent; 
                                textContent = '' + textContent; 
                            } 
                            if (type == "characteristics") { 
                                counterForCharacteristics += 1; 
                                let value = textContent.split(': '); 
                                if(settings1v6h6i5s2n9b6k0s6n7[type].selectors[0].value === value[0] && settings1v6h6i5s2n9b6k0s6n7[type].selectors[1].value === value[1]) { 
                                    settings1v6h6i5s2n9b6k0s6n7[type].needUpdate = false; 
                                } else { 
                                    settings1v6h6i5s2n9b6k0s6n7[type].needUpdate = true; 
                                    settings1v6h6i5s2n9b6k0s6n7[type].selectors[0].value = value[0]; 
                                    settings1v6h6i5s2n9b6k0s6n7[type].selectors[1].value = value[1]; 
                                } 
                            } else { 
                                if (settings1v6h6i5s2n9b6k0s6n7[type].selectors[0].value === textContent) { 
                                    settings1v6h6i5s2n9b6k0s6n7[type].needUpdate = false; 
                                } else { 
                                    settings1v6h6i5s2n9b6k0s6n7[type].needUpdate = true; 
                                    settings1v6h6i5s2n9b6k0s6n7[type].selectors[0].value = textContent; 
                                } 
                            } 
                            if(index === 0 || (type == "characteristics" && myIndex === 0)){ 
                                if (type == "characteristics") { 
                                    myIndex = 1; 
                                } 
                                if(settings1v6h6i5s2n9b6k0s6n7[type].needUpdate === true) { 
                                    settings1v6h6i5s2n9b6k0s6n7[type].selectors.forEach(item => { 
                                        updateElement3s4y0s1v1e8q2e0w4x3({ 
                                            selector: item.selector, 
                                            type: type, 
                                            updateValue: type == "options" ? selectObj : item.value 
                                        }); 
                                    }); 
                                } 
                            } else { 
                                if(settings1v6h6i5s2n9b6k0s6n7[type].needUpdate === true) { 
                                    settings1v6h6i5s2n9b6k0s6n7[type].selectors.forEach(item => { 
                                        cloneAndUpdateElement5a6r5u4j4s1k8s9h9a6({ 
                                            selector: item.selector, 
                                            updateValue: type == "options" ? selectObj : item.value, 
                                            type: type, 
                                            editable: item.editable, 
                                            isClone: true, 
                                            notCloneable: item.notCloneable 
                                        }); 
                                    }); 
                                } 
                                if (type == "characteristics" || type == "options") { 
                                    settings1v6h6i5s2n9b6k0s6n7[type].totalHeight += settings1v6h6i5s2n9b6k0s6n7[type].padding + increase; 
                                } 
                            } 
                        } 
                        if(type === "descriptions" && !textContent) { 
                            settings1v6h6i5s2n9b6k0s6n7[type].selectors.forEach((item) => { 
                                let element = document.querySelector(item.selector); 
                                if(element) { 
                                    element.style.display = "none"; 
                                } 
                            }); 
                            settings1v6h6i5s2n9b6k0s6n7[type].elemsHeight.forEach((item) => { 
                                let element = document.querySelector(item.selector); 
                                if(element) { 
                                    element.style.display = "none"; 
                                } 
                            }); 
                        } 
                        if(type == "characteristics" && index === chars.length - 1 && counterForCharacteristics === 0) { 
                            settings1v6h6i5s2n9b6k0s6n7[type].selectors.forEach((item) => { 
                                let elements = document.querySelectorAll(item.selector); 
                                if(elements.length) { 
                                    elements.forEach((element) => { 
                                        element.style.display = "none"; 
                                    }); 
                                } 
                            }); 
                            settings1v6h6i5s2n9b6k0s6n7[type].elemsHeight.forEach((item) => { 
                                let element = document.querySelector(item.selector); 
                                if(element) { 
                                    element.style.display = "none"; 
                                } 
                            }); 
                        } 
                    } 
                }); 
                if (!update) { 
                    if (type == "characteristics" || type == "options") { 
                        h_raznica = settings1v6h6i5s2n9b6k0s6n7[type].totalHeight; 
                        if(type == "characteristics") { 
                        } 
                        settings1v6h6i5s2n9b6k0s6n7[type].elemsHeight.forEach(item => { 
                            increaseHeight5a5r3l8o8y6c3z3l3c8({ selector: item.selector, updateValue: h_raznica }); 
                        }); 
                    } else { 
                        let fonShape = document.querySelector(settings1v6h6i5s2n9b6k0s6n7[type].elemsHeight[0].selector); 
                        let textElem = document.querySelector(settings1v6h6i5s2n9b6k0s6n7[type].selectors[0].selector); 
                        if (fonShape && textElem) { 
                            let fonShapeStyle = window.getComputedStyle(fonShape); 
                            let textElemStyle = window.getComputedStyle(textElem); 
                            let topDiff = parseInt(textElemStyle.top) - parseInt(fonShapeStyle.top); 
                            fonShape.style.height = parseInt(textElemStyle.height) + (topDiff*2)+ "px"; 
                        } 
                    } 
                } 
            } 
        }, 100); 
        setTimeout(() => { 
            clearInterval(int); 
        },1000); 
    } 
    // ========== ИНТЕГРАЦИЯ ЦВЕТОВЫХ ОПЦИЙ ==========
    // Функция синхронизации размера с Tilda Store
    function syncSizeWithStore(sizeValue) {
        // Ищем селект с опцией размера (на странице товара и в каталоге)
        const allSelects = document.querySelectorAll('.t-product__option select, .t-store__prod-snippet__container .t-product__option select, .js-store-product .t-product__option select');
        let sizeSelect = null;
        allSelects.forEach((select, index) => {
            const optionTitle = select.closest('.t-product__option').querySelector('.t-product__option-title');
            if (optionTitle && (
                optionTitle.textContent.toLowerCase().includes('размер') || 
                optionTitle.textContent.toLowerCase().includes('size')
            )) {
                sizeSelect = select;
            }
        });
        if (sizeSelect) {
            // Проверяем, есть ли нужное значение в опциях
            const hasValue = Array.from(sizeSelect.options).some(option => 
                option.value === sizeValue || 
                option.text === sizeValue ||
                option.value.toLowerCase().includes(sizeValue.toLowerCase()) ||
                option.text.toLowerCase().includes(sizeValue.toLowerCase())
            );
            if (hasValue) {
                // Устанавливаем выбранный размер в селекте
                sizeSelect.value = sizeValue;
                // Инициируем событие изменения
                const changeEvent = new Event('change', { bubbles: true });
                sizeSelect.dispatchEvent(changeEvent);
                // Дополнительно пытаемся найти и кликнуть по соответствующей опции
                const optionElement = Array.from(sizeSelect.options).find(option => 
                    option.value === sizeValue || 
                    option.text === sizeValue ||
                    option.value.toLowerCase().includes(sizeValue.toLowerCase()) ||
                    option.text.toLowerCase().includes(sizeValue.toLowerCase())
                );
                if (optionElement) {
                    optionElement.selected = true;
                }
                // Обновляем опции и цену
                setTimeout(function() { 
                    getProp1c4k5r9r8t7b2s6j9w8({ type: 'options', update: true }); 
                    getProp1c4k5r9r8t7b2s6j9w8({ type: 'price' }); 
                }, 500);
                // Дополнительная попытка обновления через Tilda API
                setTimeout(function() {
                    forceCatalogUpdate();
                }, 1000);
            } else {
                console.warn('Size value not found in options:', sizeValue);
            }
        } else {
            console.warn('No size select found');
        }
    }
    // Функция синхронизации выбора цвета с опциями товара в Tilda Store
    function syncColorWithStore(colorValue) {
        // Ищем все селекты с опциями товара (на странице товара и в каталоге)
        const allSelects = document.querySelectorAll('.t-product__option select, .t-store__prod-snippet__container .t-product__option select, .js-store-product .t-product__option select');
        let colorSelect = null;
        // Ищем селект с опцией цвета
        allSelects.forEach(select => {
            const optionTitle = select.closest('.t-product__option').querySelector('.t-product__option-title');
            if (optionTitle && (
                optionTitle.textContent.toLowerCase().includes('цвет') || 
                optionTitle.textContent.toLowerCase().includes('color') ||
                optionTitle.textContent.toLowerCase().includes('окрас')
            )) {
                colorSelect = select;
            }
        });
        // Если не нашли по названию, берем первый селект
        if (!colorSelect && allSelects.length > 0) {
            colorSelect = allSelects[0];
        }
        if (colorSelect) {
            // Проверяем, есть ли нужное значение в опциях
            const hasValue = Array.from(colorSelect.options).some(option => 
                option.value.toLowerCase() === colorValue.toLowerCase() ||
                option.text.toLowerCase() === colorValue.toLowerCase()
            );
            if (hasValue) {
                // Устанавливаем выбранный цвет в селекте
                colorSelect.value = colorValue;
                // Инициируем событие изменения
                const changeEvent = new Event('change', { bubbles: true });
                colorSelect.dispatchEvent(changeEvent);
                // Также пытаемся найти и кликнуть по соответствующей опции
                const optionElement = Array.from(colorSelect.options).find(option => 
                    option.value.toLowerCase() === colorValue.toLowerCase() ||
                    option.text.toLowerCase() === colorValue.toLowerCase()
                );
                if (optionElement) {
                    optionElement.selected = true;
                }
                // Обновляем опции и цену через основную функцию NLM150
                setTimeout(function() { 
                    getProp1c4k5r9r8t7b2s6j9w8({ type: 'options', update: true }); 
                    getProp1c4k5r9r8t7b2s6j9w8({ type: 'price' }); 
                }, 500);
                // Дополнительная попытка обновления через Tilda API
                setTimeout(function() {
                    forceCatalogUpdate();
                }, 1000);
            } else {
                console.warn('Color value not found in options:', colorValue);
            }
        } else {
            console.warn('No color select found');
        }
    }
    // Дополнительная функция для принудительного обновления каталога
    function forceCatalogUpdate() {
        // Пытаемся найти и обновить каталог через различные методы
        if (window.t_store) {
            if (window.t_store.updateProduct) {
                window.t_store.updateProduct();
            }
            if (window.t_store.updatePrice) {
                window.t_store.updatePrice();
            }
        }
        // Ищем и кликаем по кнопкам обновления, если они есть
        const updateButtons = document.querySelectorAll('[data-action="update"], .t-store__update-btn');
        updateButtons.forEach(btn => {
            if (btn && typeof btn.click === 'function') {
                btn.click();
            }
        });
        // Принудительно обновляем через события
        const productContainer = document.querySelector('.js-store-product');
        if (productContainer) {
            const updateEvent = new CustomEvent('tStoreVariantChange', {
                detail: { forceUpdate: true }
            });
            productContainer.dispatchEvent(updateEvent);
        }
    }
    // ========== ДИНАМИЧЕСКАЯ ИНИЦИАЛИЗАЦИЯ ЦВЕТОВ И РАЗМЕРОВ ==========
    function initDynamicOptions() {
        initDynamicSizes();
        initDynamicColors();
    }
    
    // ===== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ ЦВЕТА И ЗАКРАСКИ ИКОНКИ =====
    function extractHexFromString(str) {
        if (!str) return null;
        const m = String(str).match(/#([0-9a-f]{3,8})/i);
        return m ? `#${m[1]}` : null;
    }

    // Фолбэк-словарь, если в каталоге нет явного hex
    const COLOR_NAME_TO_HEX = {
        'розовый': '#E5AAAC',
        'графитовый': '#555D68',
        'тёплый жёлтый': '#E7C01A',
        'теплый желтый': '#E7C01A',
        'кирпичный': '#9F583A',
        'черный': '#000000',
        'чёрный': '#000000'
    };

    function resolveHexForOption(optionEl, name) {
        // 1) ищем hex в тексте
        let hex = extractHexFromString(optionEl.text);
        if (hex) return hex;

        // 2) ищем hex в value
        hex = extractHexFromString(optionEl.value);
        if (hex) return hex;

        // 3) ищем hex в data-атрибутах
        hex = optionEl.getAttribute && (optionEl.getAttribute('data-color') || optionEl.getAttribute('data-hex') || optionEl.getAttribute('data-tc-color'));
        hex = extractHexFromString(hex);
        if (hex) return hex;

        // 4) иногда цвет задают стилем background-color
        const styleAttr = optionEl.getAttribute && optionEl.getAttribute('style');
        hex = extractHexFromString(styleAttr);
        if (hex) return hex;

        // 5) ИЩЕМ В ВИЗУАЛЬНЫХ ЭЛЕМЕНТАХ TILDA (checkmark) - это основной источник HEX из каталога
        try {
            const select = optionEl.parentElement;
            if (select && select.tagName === 'SELECT') {
                const optionContainer = select.closest('.t-product__option');
                if (optionContainer) {
                    // Сопоставляем по значению опции, а не по индексу - это надежнее
                    const optionValue = optionEl.value || optionEl.text.trim();
                    
                    // Ищем label с input, у которого value совпадает со значением опции
                    const labels = optionContainer.querySelectorAll('label.t-product__option-item');
                    for (let i = 0; i < labels.length; i++) {
                        const label = labels[i];
                        const input = label.querySelector('input[type="radio"]');
                        if (input && (input.value === optionValue || input.value === optionEl.text.trim())) {
                            // Нашли соответствующий label, берем checkmark из него
                            const checkmark = label.querySelector('.t-product__option-checkmark.t-product__option-checkmark_color');
                            if (checkmark) {
                                const checkmarkStyle = checkmark.getAttribute('style') || '';
                                hex = extractHexFromString(checkmarkStyle);
                                if (hex) return hex;
                                
                                // Также проверяем computed style
                                const computedBg = window.getComputedStyle(checkmark).backgroundColor;
                                if (computedBg && computedBg !== 'rgba(0, 0, 0, 0)' && computedBg !== 'transparent') {
                                    // Конвертируем rgb/rgba в hex
                                    const rgbMatch = computedBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                                    if (rgbMatch) {
                                        const r = parseInt(rgbMatch[1]).toString(16).padStart(2, '0');
                                        const g = parseInt(rgbMatch[2]).toString(16).padStart(2, '0');
                                        const b = parseInt(rgbMatch[3]).toString(16).padStart(2, '0');
                                        hex = `#${r}${g}${b}`.toUpperCase();
                                        return hex;
                                    }
                                }
                            }
                            break; // Нашли нужный элемент, выходим
                        }
                    }
                }
            }
        } catch (e) {
            console.warn('Error extracting hex from Tilda checkmark:', e);
        }

        // 6) фолбэк по имени (только если не нашли в каталоге)
        const key = String(name || '').trim().toLowerCase();
        return COLOR_NAME_TO_HEX[key] || null;
    }

    function paintColorIcon(element, hex) {
        if (!element || !hex) return;
        // стараемся закрасить svg-шейп, если он есть
        const svg = element.querySelector && element.querySelector('svg');
        if (svg) {
            const shape = svg.querySelector('[fill]') || svg.querySelector('path, rect, circle, ellipse, polygon');
            if (shape) {
                shape.setAttribute('fill', hex);
                return;
            }
        }
        // если svg не найден — покрасим фон кружка/элемента
        element.style.backgroundColor = hex;
    }
    
    // Функция для динамической инициализации цветов из каталога
    function initDynamicColors() {
        // Ищем селект цвета в каталоге
        const colorSelect = Array.from(document.querySelectorAll('.t-product__option select')).find(select => {
            const optionTitle = select.closest('.t-product__option').querySelector('.t-product__option-title');
            return optionTitle && (
                optionTitle.textContent.toLowerCase().includes('цвет') || 
                optionTitle.textContent.toLowerCase().includes('color')
            );
        });
        
        if (!colorSelect) return;
        
        // Получаем цвета из каталога (включаем все опции, кроме первой если она пустая)
        const allOptions = Array.from(colorSelect.options).filter(opt => opt && opt.text && opt.text.trim());
        const options = allOptions.length > 1 && allOptions[0].text.trim() === '' ? allOptions.slice(1) : allOptions;

        // Преобразуем в структуру { name, hex }
        const colorItems = options.map(opt => {
            const name = opt.text.trim();
            const hex = resolveHexForOption(opt, name);
            return { name, hex };
        }).filter(it => it.name);
        
        // Находим шаблонный элемент цвета
        const firstColorElement = document.querySelector('[href="#coloricon"]');
        if (!firstColorElement) return;
        
        const parent = firstColorElement.parentNode;
        
        // Снимаем активные классы со всех существующих цветовых элементов, включая шаблон
        document.querySelectorAll('.hovercolor').forEach(function(el){
            el.classList.remove('activecolor');
        });
        
        // Удаляем все ранее созданные клоны цветов (но не трогаем шаблонный элемент и размеры)
        const existingClones = Array.from(parent.children).filter(el => 
            el.classList.contains('hovercolor') && 
            el !== firstColorElement && 
            !el.classList.contains('hoversize')
        );
        existingClones.forEach(el => el.remove());
        
        // Хелпер: выставить позиции клонов справа от первого, учитывая 12px зазор
        function positionColorClones() {
            const first = firstColorElement;
            if (!first) return;
            const parentRect = parent.getBoundingClientRect();
            const firstRect = first.getBoundingClientRect();
            const baseTop = Math.round(firstRect.top - parentRect.top + parent.scrollTop);
            const baseLeft = Math.round(firstRect.left - parentRect.left + parent.scrollLeft);
            const innerRef = first.querySelector('.tn-atom') || first;
            let diameter = Math.round(innerRef.getBoundingClientRect().width) || 24;
            if (!diameter || diameter <= 0) {
                diameter = parseInt(window.getComputedStyle(innerRef).width || '24', 10) || 24;
            }
            const gap = 12;
            const items = Array.from(parent.querySelectorAll('.hovercolor'));
            if (items.length === 0) return;
            let prevWidth = diameter;
            let accLeft = baseLeft + prevWidth + gap;
            items.forEach((el, idx) => {
                if (idx === 0) return;
                stripTildaPositionAttrs(el);
                // Ставим инлайновые стили с приоритетом !important, чтобы не перетиралось
                el.style.setProperty('position', 'absolute', 'important');
                el.style.setProperty('top', baseTop + 'px', 'important');
                el.style.setProperty('left', accLeft + 'px', 'important');
                el.dataset.colorClone = '1';
                // Получаем реальную ширину элемента для следующей итерации
                const width = Math.round(el.getBoundingClientRect().width) || diameter;
                accLeft += width + gap;
            });
        }

        // Клонируем элементы для каждого цвета
        function stripTildaPositionAttrs(elem) {
            // Удаляем атрибуты позиционирования, чтобы Tilda не перезаписывала наши инлайновые стили
            const attrs = Array.from(elem.attributes).map(a => a.name);
            attrs.forEach(name => {
                if (/^data-field-(left|top|container|axisx|axisy|width|widthunits|height|heightunits|topunits|leftunits|pos|zindex|align|valign)-value$/.test(name)) {
                    elem.removeAttribute(name);
                }
            });
        }
        let lastColorElement = firstColorElement;
        colorItems.forEach((item, index) => {
            let element;
            
            if (index === 0) {
                element = firstColorElement;
            } else {
                element = firstColorElement.cloneNode(true);
                // Вставляем после последнего вставленного цвета
                parent.insertBefore(element, lastColorElement.nextSibling);
            }
            
            element.classList.add('hovercolor');
            // Удаляем возможное состояние активности, скопированное при клонировании
            element.classList.remove('activecolor');
            element.setAttribute('data-color-name', item.name);
            if (item.hex) element.setAttribute('data-color-hex', item.hex);
            
            if (index === 0) {
                element.classList.add('activecolor');
            }
            
            // красим иконку сразу
            paintColorIcon(element, item.hex);

            // Для элементов, начиная со второго, выставим позицию позже общей функцией
            
            lastColorElement = element;
        });

        // Первая расстановка позиций
        positionColorClones();
        // Повторяем после полной загрузки (когда Tilda дорисовала/пересчитала стили)
        window.addEventListener('load', function(){
            positionColorClones();
            // Несколько раз в ближайшие 1.5с на случай поздних перерасчётов
            let n = 6; // каждые ~250мс
            const id = setInterval(function(){
                positionColorClones();
                if (--n <= 0) clearInterval(id);
            }, 250);
        });
        // При ресайзе — тоже пересчитать
        window.addEventListener('resize', positionColorClones);

        // Наблюдаем за изменениями стилей Tilda и восстанавливаем наши координаты
        const mo = new MutationObserver(function(mutations){
            let need = false;
            for (const m of mutations) {
                if (m.type === 'attributes' && m.attributeName === 'style' && m.target.classList && m.target.classList.contains('hovercolor')) {
                    // Если Tilda изменила стиль у наших клонов — пересчитаем
                    need = true; break;
                }
            }
            if (need) positionColorClones();
        });
        mo.observe(parent, { subtree: true, attributes: true, attributeFilter: ['style'] });
        
        // Устанавливаем начальный цвет и синхронизируем с Tilda Store
        if (colorItems.length > 0) {
            $('.colorname').text(colorItems[0].name);
            
            // Вызываем синхронизацию первого цвета
            setTimeout(function() {
                syncColorWithStore(colorItems[0].name);
            }, 500);
        }
        
        // Привязываем обработчик клика на цвет
        $('.hovercolor').off('click').on('click', function(e) {
            e.preventDefault();
            $('.hovercolor').removeClass('activecolor');
            $(this).addClass('activecolor');
            
            const colorName = $(this).attr('data-color-name');
            const colorHex = $(this).attr('data-color-hex');
            $('.colorname').text(colorName);
            paintColorIcon(this, colorHex);
            // Пользователь выбрал цвет вручную — помечаем и отменяем авто-инициализацию
            window._colorClicked = true;
            if (window._initFirstSizeTimeout) {
                clearTimeout(window._initFirstSizeTimeout);
                window._initFirstSizeTimeout = null;
            }
            syncColorWithStore(colorName);
            
            return false;
        });
    }
    
    // Функция для динамической инициализации размеров из каталога
    function initDynamicSizes() {
        // Ищем селект размера в каталоге
        const sizeSelect = Array.from(document.querySelectorAll('.t-product__option select')).find(select => {
            const optionTitle = select.closest('.t-product__option').querySelector('.t-product__option-title');
            return optionTitle && (
                optionTitle.textContent.toLowerCase().includes('размер') || 
                optionTitle.textContent.toLowerCase().includes('size')
            );
        });
        
        if (!sizeSelect) return;
        
        // Получаем размеры из каталога (включаем все опции, кроме первой если она пустая)
        const allSizes = Array.from(sizeSelect.options).map(opt => opt.text.trim()).filter(opt => opt);
        let sizes = allSizes.length > 1 && allSizes[0] === '' ? allSizes.slice(1) : allSizes;
        
        // Разделяем на числовые размеры и "По меркам"
        const numericSizes = [];
        const byMeasureSize = [];
        
        sizes.forEach(size => {
            const lowerSize = size.toLowerCase();
            if (lowerSize.includes('меркам') || lowerSize.includes('мерка') || lowerSize.includes('по меркам')) {
                byMeasureSize.push(size);
            } else if (size.match(/\d+/)) {
                numericSizes.push(size);
            }
        });
        
        // Сортируем числовые размеры
        numericSizes.sort((a, b) => parseInt(a) - parseInt(b));
        
        // Формируем финальный массив: числовые размеры + "По меркам"
        const finalSizes = [...new Set(numericSizes), ...byMeasureSize];
        
        // Находим шаблонный элемент размера
        const firstSizeElement = document.querySelector('[href="#sizeicon"]');
        if (!firstSizeElement) return;
        
        const parent = firstSizeElement.parentNode;
        
        // Снимаем активные классы со всех существующих элементов размера, включая шаблон
        document.querySelectorAll('.hoversize').forEach(function(el){
            el.classList.remove('activesize');
        });
        
        // Удаляем все ранее созданные клоны размеров (но не трогаем шаблонный элемент и цвета)
        const existingClonesSize = Array.from(parent.children).filter(el => 
            el.classList.contains('hoversize') && 
            el !== firstSizeElement && 
            !el.classList.contains('hovercolor')
        );
        existingClonesSize.forEach(el => el.remove());
        
        // Хелпер: удалить тильдовские позиционные атрибуты
        function stripTildaSizePositionAttrs(elem) {
            const attrs = Array.from(elem.attributes).map(a => a.name);
            attrs.forEach(name => {
                if (/^data-field-(left|top|container|axisx|axisy|width|widthunits|height|heightunits|topunits|leftunits|pos|zindex|align|valign)-value$/.test(name)) {
                    elem.removeAttribute(name);
                }
            });
        }

        // Хелпер: расставить клоны размеров справа от первого, с зазором 12px
        function positionSizeClones() {
            const first = firstSizeElement;
            if (!first) return;
            const parentRect = parent.getBoundingClientRect();
            const firstRect = first.getBoundingClientRect();
            const baseTop = Math.round(firstRect.top - parentRect.top + parent.scrollTop);
            const baseLeft = Math.round(firstRect.left - parentRect.left + parent.scrollLeft);
            const getWidth = (el) => {
                // Используем сам элемент, а не внутренний, чтобы получить реальный размер с учетом всех стилей
                let w = Math.round(el.getBoundingClientRect().width);
                if (!w || w <= 0) {
                    // Если не получается получить через getBoundingClientRect, используем computed style
                    const computedWidth = window.getComputedStyle(el).width;
                    w = parseInt(computedWidth || '24', 10) || 24;
                }
                return w;
            };
            const gap = 14;
            const items = Array.from(parent.querySelectorAll('.hoversize'));
            if (items.length === 0) return;
            let prevWidth = getWidth(items[0]);
            let accLeft = baseLeft + prevWidth + gap;
            items.forEach((el, idx) => {
                if (idx === 0) return;
                stripTildaSizePositionAttrs(el);
                const width = getWidth(el);
                el.style.setProperty('position', 'absolute', 'important');
                el.style.setProperty('top', baseTop + 'px', 'important');
                el.style.setProperty('left', accLeft + 'px', 'important');
                el.dataset.sizeClone = '1';
                accLeft += width + gap;
            });
        }

        // Клонируем элементы для каждого размера
        let lastSizeElement = firstSizeElement;
        finalSizes.forEach((size, index) => {
            let element;
            
            if (index === 0) {
                element = firstSizeElement;
            } else {
                element = firstSizeElement.cloneNode(true);
                // Вставляем после последнего вставленного размера
                parent.insertBefore(element, lastSizeElement.nextSibling);
                lastSizeElement = element;
            }
            
            element.classList.add('hoversize');
            // Удаляем возможное состояние активности, скопированное при клонировании
            element.classList.remove('activesize');
            element.setAttribute('data-size-value', size);
            
            // Обновляем текст размера
            const textElement = element.querySelector('.tn-atom');
            if (textElement) {
                // Для "По меркам" пишем полностью, для числовых - только число
                if (size.toLowerCase().includes('меркам') || size.toLowerCase().includes('по меркам')) {
                    textElement.textContent = size;
                } else {
                    // Пишем просто число
                    textElement.textContent = size;
                }
            }
            
            if (index === 0) {
                element.classList.add('activesize');
            }
        });
        
        // Сохраняем последний размер
        window._lastSizeElement = lastSizeElement;
        
        // Перенос строки для размеров больше не добавляется, сохраняем исходную разметку Tilda
        
        // Расставляем позиции размеров
        positionSizeClones();
        window.addEventListener('load', function(){
            positionSizeClones();
            let n = 6;
            const id = setInterval(function(){
                positionSizeClones();
                if (--n <= 0) clearInterval(id);
            }, 250);
        });
        window.addEventListener('resize', positionSizeClones);

        // Наблюдаем за изменениями стилей и восстанавливаем позиции при правках Tilda
        const sizeMo = new MutationObserver(function(mutations){
            for (const m of mutations) {
                if (m.type === 'attributes' && m.attributeName === 'style' && m.target.classList && m.target.classList.contains('hoversize')) {
                    positionSizeClones();
                    break;
                }
            }
        });
        sizeMo.observe(parent, { subtree: true, attributes: true, attributeFilter: ['style'] });

        // Синхронизируем первый размер с Tilda Store
        if (finalSizes.length > 0) {
            setTimeout(function() {
                syncSizeWithStore(finalSizes[0]);
            }, 500);
        }
        
        // Привязываем обработчик клика на размер
        $('.hoversize').off('click').on('click', function(e) {
            e.preventDefault();
            $('.hoversize').removeClass('activesize');
            $(this).addClass('activesize');
            
            const sizeValue = $(this).attr('data-size-value');
            // Помечаем, что пользователь взаимодействовал с размерами,
            // и гасим отложенную авто-инициализацию первого размера
            window._sizeClicked = true;
            if (window._initFirstSizeTimeout) {
                clearTimeout(window._initFirstSizeTimeout);
                window._initFirstSizeTimeout = null;
            }
            syncSizeWithStore(sizeValue);
            
            return false;
        });
    }
    
        // Инициализируем динамические опции
    initDynamicOptions();
    
    // Дополнительные вызовы после загрузки
    window.addEventListener('load', function() {
        setTimeout(initDynamicOptions, 100);
        setTimeout(initDynamicOptions, 500);
    });
    
    // Инициализируем цветовые опции после загрузки DOM
    $(document).ready(function() {
        initDynamicOptions();
        
        // Автоматически выбираем первый цвет и размер при загрузке
        // Откладываем авто-выбор первого цвета/размера, но не вмешиваемся,
        // если пользователь уже что-то выбрал или актив уже расставлен
        window._initFirstSizeTimeout = setTimeout(function() {
            const firstColor = document.querySelector('.hovercolor[data-color-name]');
            const hasActiveColor = !!document.querySelector('.hovercolor.activecolor');
            if (!window._colorClicked && firstColor && !hasActiveColor && !firstColor.classList.contains('activecolor')) {
                firstColor.classList.add('activecolor');
                const colorName = firstColor.getAttribute('data-color-name');
                syncColorWithStore(colorName);
            }
            
            const firstSize = document.querySelector('.hoversize[data-size-value]');
            const hasActiveSize = !!document.querySelector('.hoversize.activesize');
            if (!window._sizeClicked && firstSize && !hasActiveSize && !firstSize.classList.contains('activesize')) {
                firstSize.classList.add('activesize');
                const sizeValue = firstSize.getAttribute('data-size-value');
                syncSizeWithStore(sizeValue);
            }
            window._initFirstSizeTimeout = null;
        }, 2000);
    });
    setTimeout(function(){ 
        let renderInt = setInterval(function() { 
            if (window.isAllElemsRendered1450750621) { 
                clearInterval(renderInt); 
                for (let key in settings1v6h6i5s2n9b6k0s6n7) { 
                    getProp1c4k5r9r8t7b2s6j9w8({ type: key }); 
                } 
                window.dispatchEvent(new Event('resize')); 
                activateButton4e6c6l4f7y0l5n9s1q7(); 
                activateWishButton6z4s7y2e0x9n1x2r0h8(); 
            } 
        },100); 
        setTimeout(() => { 
            clearInterval(renderInt); 
        },1000); 
        const intForCountSlides = setInterval(() => { 
            const itemsWrapper = document.querySelector(".js-store-product .t-slds__items-wrapper"); 
            if (!itemsWrapper) { 
                const galleryFromZeroBlock = document.querySelector(zeroId + ' [data-elem-type="gallery"]'); 
                if(galleryFromZeroBlock) { 
                    galleryFromZeroBlock.remove(); 
                } 
            } 
            if(itemsWrapper) { 
                const totalCountSlides = itemsWrapper.getAttribute("data-slider-totalslides"); 
                clearInterval(intForCountSlides); 
                if(totalCountSlides === '1') { 
                    let intForArrowSliderContainerList = setInterval(() => { 
                        const arrowSliderContainerList = document.querySelectorAll(".t-slds__arrow_container"); 
                        if (arrowSliderContainerList.length > 0) { 
                            clearInterval(intForArrowSliderContainerList); 
                            arrowSliderContainerList.forEach((arrowSliderContainer) => { 
                                arrowSliderContainer.style.display = "none"; 
                            }); 
                        } 
                    },100); 
                    setTimeout(() => { 
                        clearInterval(intForArrowSliderContainerList); 
                    },1000); 
                    let intForBulletSliderContainerList = setInterval(() => { 
                        const bulletSliderContainerList = document.querySelectorAll(".t-slds__bullet_wrapper"); 
                        if (bulletSliderContainerList.length > 0) { 
                            clearInterval(intForBulletSliderContainerList); 
                            bulletSliderContainerList.forEach((bulletSliderContainer) => { 
                                bulletSliderContainer.style.display = "none"; 
                            }); 
                        } 
                    },100); 
                    setTimeout(() => { 
                        clearInterval(intForBulletSliderContainerList); 
                    },1000) 
                } 
            } 
        },100); 
        setTimeout(() => { 
            clearInterval(intForCountSlides); 
        },1000) 
    },1000); 
    function updateAfterResize4r8m0c7v8v1i6j8p2a8() { 
        for (let key in settings1v6h6i5s2n9b6k0s6n7) { 
            document.querySelectorAll(zeroId + " ." + key + "_cloned").forEach(function(item) { 
                item.remove(); 
            }); 
            settings1v6h6i5s2n9b6k0s6n7[key].totalHeight = 0; 
            settings1v6h6i5s2n9b6k0s6n7[key].clonedElements = []; 
            let fonShape = document.querySelector(settings1v6h6i5s2n9b6k0s6n7[key].elemsHeight[0].selector); 
            if (fonShape) { 
                fonShape.style.height = fonShape.getAttribute("data-field-height-value") + "px"; 
            } 
        } 
        for (let key in settings1v6h6i5s2n9b6k0s6n7) { 
            getProp1c4k5r9r8t7b2s6j9w8({ type: key }); 
        } 
    } 
    function debounce0b7p1b9q6t5o6b2j2z3(fn, delay) { 
        let timeoutID = null; 
        return function() { 
            if (timeoutID) { 
                clearTimeout(timeoutID); 
            } 
            const args = arguments; 
            const that = this; 
            timeoutID = setTimeout(function() { 
                fn.apply(that, args); 
            }, delay); 
        } 
    } 
    let firstResize = true; 
    const resizeChange1a9i5z0u9u9f1p6u1f8 = debounce0b7p1b9q6t5o6b2j2z3(function() { 
        if(firstResize) { 
            if(1 !== 1) { 
                loaderShow(); 
            } 
            if(window.innerWidth < 640) { 
                firstResize = false; 
            } 
            setTimeout(function() { 
                updateAfterResize4r8m0c7v8v1i6j8p2a8(); 
                setTimeout(function() { 
                    getProp1c4k5r9r8t7b2s6j9w8({ type: 'options', update: true }); 
                    getProp1c4k5r9r8t7b2s6j9w8({ type: 'price' }); 
                    if(1 !== 1) { 
                        setTimeout(function() { 
                            loaderHide(); 
                        }, 100); 
                    } 
                }, 100); 
            },500); 
        } 
    }, 1500); 
    window.addEventListener("resize", function() { 
        resizeChange1a9i5z0u9u9f1p6u1f8(); 
    }); 
    function adjustGroups7x6n5k7g9a9f9i8s8t9(settings1v6h6i5s2n9b6k0s6n7, type) { 
        const calculateTotalHeight = (elements) => elements.reduce((sum, el) => sum + el.offsetHeight, 0); 
        function getGroupRect8j4i9m9u7g7q4w6t1j7(elements) { 
            const scrollOffsetY = window.scrollY; 
            const scrollOffsetX = window.scrollX; 
            return elements.reduce((rect, elem) => { 
                const elemStyle = window.getComputedStyle(elem); 
                const elemRect = elem.getBoundingClientRect(); 
                let zm = 1; 
                if (elem.hasAttribute("data-scale-off") && elem.getAttribute("data-scale-off") === "yes") { 
                    elem.closest(".t396__artboard").querySelectorAll(".t396__elem").forEach(function(item) { 
                        let elemZoom = checkZoom3z8g2l3q2q6k2h2r0i8(item); 
                        if (elemZoom !== 1) { 
                            zm = elemZoom; 
                        } 
                    }); 
                } 
                rect.top = Math.min(rect.top, (elemRect.top + scrollOffsetY) / zm - parseFloat(elemStyle.marginTop) / zm); 
                rect.right = Math.max(rect.right, (elemRect.right + scrollOffsetX) / zm + parseFloat(elemStyle.marginRight) / zm); 
                rect.bottom = Math.max(rect.bottom, (elemRect.bottom + scrollOffsetY) / zm + parseFloat(elemStyle.marginBottom) / zm); 
                rect.left = Math.min(rect.left, (elemRect.left + scrollOffsetX) / zm - parseFloat(elemStyle.marginLeft) / zm); 
                return rect; 
            }, {top: Infinity, right: -Infinity, bottom: -Infinity, left: Infinity}); 
        } 
        const areGroupsInSameColumn = (group1, group2) => { 
            return !(group1.rect.right < group2.rect.left || group1.rect.left > group2.rect.right); 
        }; 
        let groupsData = Object.keys(settings1v6h6i5s2n9b6k0s6n7).map(type => { 
            const selectors = settings1v6h6i5s2n9b6k0s6n7[type].selectors.map(sel => sel.selector).concat(settings1v6h6i5s2n9b6k0s6n7[type].elemsHeight.map(heightElem => heightElem.selector)); 
            const elements = selectors.flatMap(selector => Array.from(document.querySelectorAll(selector))); 
            const clonedElements = settings1v6h6i5s2n9b6k0s6n7[type].clonedElements || []; 
            return { 
                type: type, 
                elements: elements.concat(clonedElements), 
                rect: getGroupRect8j4i9m9u7g7q4w6t1j7(elements.concat(clonedElements)), 
                marginBottom: settings1v6h6i5s2n9b6k0s6n7[type].marginBottom, 
                marginBottomMobile: settings1v6h6i5s2n9b6k0s6n7[type].marginBottomMobile, 
            }; 
        }).sort((a, b) => a.rect.top - b.rect.top); 
        groupsData = groupsData.filter((item) => item.elements.length > 0); 
        function getMaxBottom0d1z9c4a3l2k9a4n5t5(groupsData) { 
            let maxBottom = 0; 
            groupsData.forEach(function(item) { 
                if ((item.rect.bottom ) > maxBottom) { 
                    maxBottom = item.rect.bottom ; 
                } 
            }); 
            return maxBottom; 
        } 
        function isGroupOnShape(shape, groups) { 
            const rect1 = shape.getBoundingClientRect(); 
            const adjustedRect1 = { 
                top: rect1.top + window.scrollY, 
                right: rect1.right + window.scrollX, 
                bottom: rect1.bottom + window.scrollY, 
                left: rect1.left + window.scrollX 
            }; 
            let groupsOnShape = []; 
            groups.forEach((group) => { 
                const rect2 = { 
                    top: group.rect.top, 
                    right: group.rect.right, 
                    bottom: group.rect.bottom, 
                    left: group.rect.left 
                }; 
                let overlap = !(rect2.right < adjustedRect1.left || 
                                rect2.left > adjustedRect1.right || 
                                rect2.bottom < adjustedRect1.top || 
                                rect2.top > adjustedRect1.bottom); 
                if (overlap) { 
                    groupsOnShape.push(group); 
                } 
            }); 
            return groupsOnShape.sort((a, b) => a.rect.top - b.rect.top); 
        } 
        function isGroupOnGroup(currentGroup, nextGroup) { 
            let groupOnGroup = false; 
            let currentGroupRect = currentGroup.elements[0].getBoundingClientRect(); 
            nextGroup.elements.forEach((nextElement) => { 
                if(groupOnGroup) { 
                    return; 
                } 
                let nextElementRect = nextElement.getBoundingClientRect(); 
                let isNextElementOnCurrentElement = nextElementRect.top >= currentGroupRect.top && nextElementRect.left >= currentGroupRect.left && nextElementRect.right <= currentGroupRect.right && nextElementRect.bottom <= currentGroupRect.bottom; 
                if(isNextElementOnCurrentElement) { 
                    groupOnGroup = true; 
                } 
            }); 
            return groupOnGroup; 
        } 
        let groupsOnShape; 
        if(mainShape) { 
            groupsOnShape = isGroupOnShape(mainShape,groupsData); 
        } 
        if (type == "start") { 
            maxBottom1 = getMaxBottom0d1z9c4a3l2k9a4n5t5(groupsData); 
            if(groupsOnShape && groupsOnShape.length > 0) { 
                maxBottomInShape = getMaxBottom0d1z9c4a3l2k9a4n5t5(groupsOnShape); 
            } 
            return false; 
        } 
        for (let i = 0; i < groupsData.length; i++) { 
            const currentGroup = groupsData[i]; 
            for (let j = i + 1; j < groupsData.length; j++) { 
                const nextGroup = groupsData[j]; 
                if (areGroupsInSameColumn(currentGroup, nextGroup)) { 
                    if(currentGroup.type === "gallery" && (nextGroup.type === "wishButton" || nextGroup.type === "buyButton" || nextGroup.type === "price")) { 
                        if(isGroupOnGroup(currentGroup,nextGroup)) { 
                            nextGroup.isOnAnotherGroup = true; 
                        } 
                    } 
                } 
            } 
        } 
        for (let i = 0; i < groupsData.length; i++) { 
            const currentGroup = groupsData[i]; 
            for (let j = i + 1; j < groupsData.length; j++) { 
                const nextGroup = groupsData[j]; 
                if (areGroupsInSameColumn(currentGroup, nextGroup)) { 
                    if(currentGroup.type === "gallery" && (nextGroup.type === "wishButton" || nextGroup.type === "buyButton" || nextGroup.type === "price")) { 
                        if(isGroupOnGroup(currentGroup,nextGroup) && nextGroup.isOnAnotherGroup) { 
                            continue; 
                        } 
                    } 
                    let gap = nextGroup.rect.top - currentGroup.rect.bottom; 
                    let currentMarginBottom = window.innerWidth > 480 ? currentGroup.marginBottom : currentGroup.marginBottomMobile; 
                    if (gap < currentMarginBottom) { 
                        let offset = currentMarginBottom - gap; 
                        if (offset > 0) { 
                            nextGroup.elements.forEach(elem => { 
                                const currentTop = parseInt(elem.style.top, 10) || elem.offsetTop; 
                                let zm = 1; 
                                if (elem.hasAttribute("data-scale-off") && elem.getAttribute("data-scale-off") == "yes") { 
                                    elem.closest(".t396__artboard").querySelectorAll(".t396__elem").forEach(function(item) { 
                                        let elemZoom = checkZoom3z8g2l3q2q6k2h2r0i8(item); 
                                        if (elemZoom != 1) { 
                                            zm = elemZoom; 
                                        } 
                                    }); 
                                } 
                                elem.style.top = `${Math.round(currentTop + offset*zm)}px`; 
                            }); 
                            nextGroup.rect = getGroupRect8j4i9m9u7g7q4w6t1j7(nextGroup.elements); 
                        } 
                    } 
                } 
            } 
        } 
        groupsData = groupsData.reduce((acc,group) => { 
            let elementsCount = group.elements.length; 
            let hiddenElementsCount = 0; 
            group.elements.forEach((element) => { 
                if(element.style.display === 'none') { 
                    hiddenElementsCount ++; 
                } 
            }); 
            if(elementsCount === hiddenElementsCount) { 
                return acc; 
            } else { 
                acc.push(group); 
                return acc; 
            } 
        },[]); 
        maxBottom2 = getMaxBottom0d1z9c4a3l2k9a4n5t5(groupsData); 
        const zeroBlock = document.querySelector(zeroId); 
        let zeroBlockTop = zeroBlock.getBoundingClientRect().top + window.scrollY; 
        if(groupsOnShape && groupsOnShape.length > 0) { 
            newMaxBottomInShape = getMaxBottom0d1z9c4a3l2k9a4n5t5(groupsOnShape); 
        } 
        let lastGroup = groupsData[groupsData.length - 1]; 
        let lastGroupOnShape; 
        if(groupsOnShape && groupsOnShape.length) { 
            lastGroupOnShape = groupsOnShape[groupsOnShape.length - 1]; 
        } 
        function increaseBlockHeight2d9h8d4r0c6z8u5e8f3(lastGroupMarginBottom) { 
            let mainShape = document.querySelector(zeroId + ' .' + "tn-elem__14507506211760890267356"); 
            let mainShapeBottom = 0; 
            if(mainShape) { 
                mainShapeBottom = mainShape.getBoundingClientRect().bottom + window.scrollY; 
            } 
            let zm = 1; 
            let elemZoom = checkZoom3z8g2l3q2q6k2h2r0i8(document.querySelector(zeroId + " .t396__elem")); 
            if (elemZoom != 1) { 
                zm = elemZoom; 
            } 
            document.querySelectorAll(zeroId + " .t396__artboard, " + zeroId + " .t396__carrier, " + zeroId + " .t396__filter").forEach(function(item) { 
                let h = window.getComputedStyle(item).height.slice(0,-2); 
                let maxBottom = maxBottom2 > mainShapeBottom ? maxBottom2 : mainShapeBottom; 
                let computedHeight=Math.floor(maxBottom)*zm - Math.floor(zeroBlockTop)*zm + lastGroupMarginBottom ; 
                let resultHeight= h.substr() >= computedHeight ? h : computedHeight; 
                item.style.setProperty('height', resultHeight+'px', 'important'); 
            }); 
        } 
        function increaseShapeHeight2d9h8d4r0c6z8u5e8f3(lastGroupOnShapeMarginBottom) { 
            let zm = 1; 
            let elemZoom = checkZoom3z8g2l3q2q6k2h2r0i8(document.querySelector(zeroId + " .t396__elem")); 
            if (elemZoom != 1) { 
                zm = elemZoom; 
            } 
            const mainShapeTop = parseInt(mainShape.style.top, 10); 
            const increasedMainShapeHeight = Math.floor(newMaxBottomInShape)*zm - Math.floor(zeroBlockTop)*zm + lastGroupOnShapeMarginBottom - mainShapeTop; 
            mainShape.style.setProperty('height', increasedMainShapeHeight + "px", 'important'); 
        } 
        const intForJsStoreProduct = setInterval(() => { 
            const jsStoreProduct = document.querySelector('.js-store-product'); 
            const priceElem = document.querySelector('.js-store-prod-price-val.t-store__prod-popup__price-value'); 
            const newPrice = priceElem.innertext; 
            const zeroPriceElem = document.querySelector('.tn-elem__1450750621176088907676191580 .tn-atom'); 
            if(zeroPriceElem && newPrice) { 
                let newPriceForZero = ''; 
                if('') { 
                    newPriceForZero += ''; 
                } 
                newPriceForZero += newPrice; 
                if(' ₽') { 
                    newPriceForZero += ' ₽'; 
                } 
                zeroPriceElem.innerText = newPriceForZero; 
            } 
            if(!jsStoreProduct) return; 
            clearInterval(intForJsStoreProduct); 
            function tStoreVariantChangeHandler () { 
                const activeSlide = jsStoreProduct.querySelector('.t-slds__bullet_active'); 
                if(activeSlide) { 
                    const indexSlide = activeSlide.getAttribute('data-slide-bullet-for'); 
                    const slideInZeroForClick = zeroBlock.querySelector('.t-slds__bullet[data-slide-bullet-for="' + indexSlide + '"]'); 
                    if(slideInZeroForClick) { 
                        slideInZeroForClick.click(); 
                    } 
                }
                // Обновляем текст кнопки при изменении варианта товара
                if (window.updateButtonTextForMobile) {
                    window.updateButtonTextForMobile();
                }
            } 
            jsStoreProduct.removeEventListener('tStoreVariantChange', tStoreVariantChangeHandler); 
            jsStoreProduct.addEventListener('tStoreVariantChange', tStoreVariantChangeHandler); 
        },100); 
        setTimeout(() => { 
            clearInterval(intForJsStoreProduct); 
        },3000); 
        if(mainShape) { 
            window.innerWidth > 640 ? increaseShapeHeight2d9h8d4r0c6z8u5e8f3(lastGroupOnShape.marginBottom) : increaseShapeHeight2d9h8d4r0c6z8u5e8f3(lastGroupOnShape.marginBottomMobile); 
        } 
        window.innerWidth > 640 ? 
            increaseBlockHeight2d9h8d4r0c6z8u5e8f3(lastGroup.marginBottom) :
            increaseBlockHeight2d9h8d4r0c6z8u5e8f3(lastGroup.marginBottomMobile); 
    } 
}); 
</script>
<style>
.nolimAutoScaleFix { 
height: 0!important; 
max-height: 0!important; 
min-height: 0!important; 
pointer-events: none!important; 
overflow: hidden!important; 
padding-top: 0!important; 
padding-bottom: 0!important; 
position: absolute; 
bottom: -100000px; 
} 
.t-nolim-select { 
min-width: 100%; 
box-sizing: border-box; 
cursor: pointer; 
height: 60px; 
padding: 0 45px 0 20px; 
font-size: 16px; 
line-height: 1.33; 
outline: none; 
border: 0; 
border-radius: 0; 
background: transparent; 
color: initial; 
-webkit-appearance: none; 
appearance: none; 
-moz-appearance: none; 
} 
.tn-elem__1450750621176088907676191580 .tn-atom { 
white-space: nowrap; 
}
@media (max-width: 640px) {
.tn-elem__1450750621176088907676191580 {
text-align: center !important;
display: flex !important;
justify-content: center !important;
}
.tn-elem__1450750621176088907676191580 .tn-atom {
text-align: center !important;
margin: 0 auto !important;
}
} 
.t-store__prod-snippet__container .t-store__prod-popup__close-txt-wr, 
.t-store__prod-snippet__container .t-popup__close, 
.t-store__prod-snippet__container .js-store-product{ 
display: none!important; 
} 
.t-store__prod-snippet__container { 
padding-top: 0px!important; 
padding-bottom: 0px!important; 
} 
.tn-elem__14507506211760888749616, 
.tn-elem__14507506211760888887430, 
.removeFavoriteClassNlm150 { 
cursor: pointer; 
} 
.loader__overlay { 
width: 100%; 
height: 100%; 
position: fixed; 
top: 0; 
right: 0; 
bottom: 0; 
left: 0; 
z-index: 999999; 
background-color: #fff; 
} 
.loader__container { 
width: 100%; 
height: 100%; 
position: absolute; 
top: 0; 
right: 0; 
bottom: 0; 
left: 0; 
z-index: 9999999; 
transition: 0.6s; 
display: flex; 
align-items: center; 
justify-content: center; 
} 
.loader { 
width: 75px; 
height: 75px; 
border: 10px solid #ffffff; 
border-radius: 50%; 
border-left-color: #ffffff; 
animation: loader 1.3s linear infinite; 
} 
@keyframes loader { 
100% { 
transform: rotate(360deg); 
} 
}
/* Стили для цветовых опций */
.hovercolor {
    cursor: pointer;
    border-radius: 50%;
    /* Не трогаем размещение, сохраняем абсолютное позиционирование Tilda */
    /* display, position, top/left и размеры — как в исходных стилях Tilda */
}
.activecolor {
box-shadow: 0px 0px 0px 3px #ffffff, 0px 0px 0px 4px #000000 !important;
}
.colortext {
font-weight: bold;
margin-left: 10px;
}
/* Стили для размеров */
.hoversize {
cursor: pointer;
border-radius: 50%;
display: flex !important;
align-items: center !important;
justify-content: center !important;
margin-right: 8px !important;
position: relative !important;
width: 24px !important;
height: 24px !important;
box-sizing: border-box !important;
}
.activesize {
box-shadow: 0px 0px 0px 3px #ffffff, 0px 0px 0px 4px #000000 !important;
background-color: #ffffff;
}
/* Специальный стиль для "ПО МЕРКАМ" */
.hoversize[data-size-value*="меркам"],
.hoversize[data-size-value*="мерка"] {
width: 78px !important;
height: 30px !important;
border-radius: 2px !important;
margin-top: -4px !important;
padding: 8px 4px !important;
text-align: center !important;
border: 1px solid transparent !important;
box-sizing: border-box !important;
}
.hoversize[data-size-value*="меркам"].activesize,
.hoversize[data-size-value*="мерка"].activesize {
border: 1px solid #000000 !important;
border-radius: 5px !important;
box-shadow: none !important;
padding: 8px 4px !important;
}
/* Стили для внутреннего содержимого размеров */
.hoversize .tn-atom {
font-size: 12px !important;
line-height: 1 !important;
}
.hoversize[data-size-value*="меркам"] .tn-atom,
.hoversize[data-size-value*="мерка"] .tn-atom {
font-size: 11px !important;
line-height: 1.2 !important;
white-space: nowrap !important;
text-transform: uppercase !important;
text-align: center !important;
padding: 0 !important;
margin: 0 !important;
width: 100% !important;
height: 100% !important;
display: block !important;
}
/* Стили для внутреннего содержимого цветов */
.hovercolor .tn-atom {
font-size: 0 !important;
overflow: hidden !important;
}
/* Стили для описания товара */
.tn-elem__1450750621176088924800187760 {
font-family: 'Raleway', sans-serif !important;
font-size: 14px !important;
font-weight: 500 !important;
}
/* Стили для названия цвета */
.colorname {
font-family: 'Raleway', sans-serif !important;
font-size: 14px !important;
font-weight: 500 !important;
}
/* Стили для заголовка товара */
.tn-elem__1450750621176096459787649250 {
text-align: center !important;
}
.tn-elem__1450750621176096459787649250 .tn-atom {
text-align: center !important;
}
/* Стили для галереи миниатюр */
.gallery-wrapper {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    gap: 20px;
    width: 100%;
}
.thumbnail-gallery-container {
    display: flex;
    flex-direction: column;
    gap: 12px;
    width: 80px;
    flex-shrink: 0;
    align-items: flex-start;
}
.thumbnail-item {
    width: 80px;
    height: auto;
    aspect-ratio: 9 / 16;
    cursor: pointer;
    border: 2px solid transparent;
    border-radius: 0;
    overflow: hidden;
    transition: all 0.3s ease;
    background: #f5f5f5;
    position: relative;
    flex-shrink: 0;
}
.thumbnail-item:hover {
    border-color: #000;
    opacity: 0.8;
}
.thumbnail-item.active {
    border-color: #000;
    border-width: 2px;
}
.thumbnail-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}
/* Контейнер для галереи с миниатюрами */
#rec1450750621 [data-elem-type="gallery"] {
    flex: 1;
    min-width: 0;
    align-self: flex-start;
}
/* Убираем отступы у элемента галереи и его родителей */
#rec1450750621 .tn-elem__14507506211760950710118 {
    padding-top: 0 !important;
    margin-top: 0 !important;
}
#rec1450750621 .tn-elem__14507506211760950710118 .tn-atom {
    padding-top: 0 !important;
    margin-top: 0 !important;
}
/* Выравниваем миниатюры по верху с галереей */
.thumbnail-gallery-container {
    align-self: flex-start;
}
/* На мобильных устройствах: скрываем миниатюры, показываем точки внизу */
@media (max-width: 640px) {
    .gallery-wrapper {
        flex-direction: column;
        gap: 0;
    }
    /* Скрываем миниатюры на мобильной версии */
    .thumbnail-gallery-container {
        display: none !important;
    }
    /* Точки внутри изображения по дизайну из Figma */
    #rec1450750621 [data-elem-type="gallery"] .t-slds {
        position: relative !important;
    }
    #rec1450750621 [data-elem-type="gallery"] .t-slds__bullet_wrapper {
        position: absolute !important;
        bottom: 12px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        display: flex !important;
        justify-content: center !important;
        align-items: center !important;
        gap: 4px !important;
        z-index: 10 !important;
        padding: 0 !important;
        margin: 0 !important;
    }
    /* Стили конкретно для точек - убираем обводку */
    #rec1450750621 [data-elem-type="gallery"] .t-slds__bullet {
        width: 6px !important;
        height: 6px !important;
        min-width: 6px !important;
        min-height: 6px !important;
        max-width: 6px !important;
        max-height: 6px !important;
        border-radius: 50% !important;
        background-color: #2B2B2B !important;
        border: none !important;
        outline: none !important;
        box-shadow: none !important;
        cursor: pointer !important;
        transition: all 0.3s ease !important;
        padding: 0 !important;
        margin: 0 !important;
        opacity: 0.3 !important;
        flex-shrink: 0 !important;
    }
    #rec1450750621 [data-elem-type="gallery"] .t-slds__bullet_active {
        width: 18px !important;
        height: 6px !important;
        min-width: 18px !important;
        min-height: 6px !important;
        max-width: 18px !important;
        max-height: 6px !important;
        border-radius: 3px !important;
        background-color: #2B2B2B !important;
        border: none !important;
        outline: none !important;
        box-shadow: none !important;
        opacity: 1 !important;
    }
    /* Отключаем клики на левую/правую область галереи для переключения, но оставляем touch для свайпа */
    #rec1450750621 [data-elem-type="gallery"] .t-slds__area {
        pointer-events: none;
    }
    /* Включаем клики и touch только на само изображение (для увеличения и свайпа) */
    #rec1450750621 [data-elem-type="gallery"] .t-slds__item,
    #rec1450750621 [data-elem-type="gallery"] .t-slds__bgimg {
        pointer-events: auto;
        touch-action: pan-y pinch-zoom;
    }
    /* Точки-индикаторы должны быть кликабельными */
    #rec1450750621 .t-slds__bullet {
        pointer-events: auto;
    }
}

/* Скрытие элементов cartbutton и favbutt на мобильных устройствах */
@media (max-width: 768px) {
    .cartbutton,
    .favbutt {
        display: none !important;
    }
}
</style>